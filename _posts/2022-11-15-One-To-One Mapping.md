---
layout: post
title: "One-To-One Mapping"
date: 2022-11-15
categories: BackendFrameworks
---

In this post, I will discuss what options Hibernate and Entity Framework Core give us to configure One-To-One Relationships between entities.

There are three main approaches to map one-to-one relationship:

1) Shared primary key

2) Separate foreign key column

3) Intermediate (Joined) table

## Shared primary key

### Hibernate
      
In this strategy, two associated entities share the primary key. In one of them, the primary key is also a foreign key, which references the another. This is a very nice strategy, however the difficulty of this approach is that we are reponsible to correctly assign the same primary key value, and we have to save the entity that has it’s primary key auto-generated (or at least, ALREADY generated before saving the other one) first.
The classes are defined as follows:

![OneToOneClasses](/assets/OTO-SP-Classes.png)

We can configure everything with annotations, which in this case are relatively simple: In the Address class, we annotate the User field with @OneToOne, which indicates the nature of the relationship, and with @PrimaryKeyJoinColumn, which indicates that Address’s primary key should also be a foreign key. In the User class, the address field is also annotated with @OneToOne, but with mappedBy parameter, we tell Hibernate that the foreign key is already mapped on the other side, so we don’t need additional column on this entity’s table. 

Additionally, we choose lazy loading strategy, which is preferred most of the time over eager.
If we choose to make this relatinoship unidirectional, we can simply remove Address field from User entity (not the other way, because user is the one with autogenerated Id).

Hibernate provides us with clean and intuitive solution. If we persist entities carefully and correctly, everything should work as expected.


