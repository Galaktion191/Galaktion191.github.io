---
layout: post
title: "One-To-One Mapping"
date: 2022-11-15
categories: BackendFrameworks
---

In this post, I will discuss what options Hibernate and Entity Framework Core give us to configure One-To-One Relationships between entities.

There are three main approaches to map one-to-one relationship:

1) Shared primary key

2) Separate foreign key column

3) Intermediate (Joined) table

## Shared primary key

### Hibernate
      
In this strategy, two associated entities share the primary key. In one of them, the primary key is also a foreign key, which references the another. This is a very nice strategy, however the difficulty of this approach is that we are reponsible to correctly assign the same primary key value, and we have to save the entity that has it’s primary key auto-generated (or at least, ALREADY generated before saving the other one) first.
The classes are defined as follows:

![OneToOneClasses](/assets/OTO-SP-Classes.png)

We can configure everything with annotations, which in this case are relatively simple: In the Address class, we annotate the User field with @OneToOne, which indicates the nature of the relationship, and with @PrimaryKeyJoinColumn, which indicates that Address’s primary key should also be a foreign key. In the User class, the address field is also annotated with @OneToOne, but with mappedBy parameter, we tell Hibernate that the foreign key is already mapped on the other side, so we don’t need additional column on this entity’s table. 

Additionally, we choose lazy loading strategy, which is preferred most of the time over eager.
If we choose to make this relatinoship unidirectional, we can simply remove Address field from User entity (not the other way, because user is the one with autogenerated Id).

Hibernate provides us with clean and intuitive solution. If we persist entities carefully and correctly, everything should work as expected.

### Entity Framework Core

This approach is very easy and intuitive in EF Core as well, with the main difference being how it is configured. Instead of annotations on entities, we configure relationship details in OnModelCreating method. User class is defined in very "normal" way which does not need further explanation. Address class is defined as follows:

![AddressC#](/assets/OTOC#-SP.png)

As you can see, we have no annotations except for [Key], which indicates the primary key. By default, in EF Core primary keys are auto-generated(incremented) and we don't need annoation like Hibernate's @GeneratedValue. For this reason, we explicitly set Id in constructor (along with user). The configuration happens in Database Context's OnModelCreating method like this:

![OnModelCreating](/assets/OTOC#-SP-M.png)

EF Core offers us clean and nice solution. We state that Address has one user, followed up with WithOne() method, which indicates that relationship is one-to-one. Since in this case we are configuring unidirectional relationship, WithOne() method (which indicates User's reference to Address) takes no arguments, and finally we define which field we want Address to use as a foreign key. 

This configuration is very sophisticated, but the main praise for EF Core is still yet to come. As stated above, in Hibernate, we have to make sure that an entity with autogenerated Id is saved first, followed up by the dependent one. EF Core saves us from this trouble and takes cares care of things with in a very clean way: We add everything to the database context, and it will do the rest. We don't have to explicitly save one entity before the other. Here is an example for this case:

![C#DatabaseContext](/assets/OTOC#-SP-P.png)

Even if we added address before user, it would still work perfectly. In this matter, EF Core provides arguably better solution than Hibernate.


## Separate foreign key column

Instead of sharing the same primary key values, we can create separate column that will have referencing foreign keys, and make both entities independent in the matter of Id generation. Surprisingly, implementing this approach is very similar. Even if we already configured previous approach but decided to move to this one, we only have to change few lines.

### Hibernate

In Hibernate, implementing this strategy is almost exactly the same, we just have to change a single annotation: instead of @PrimaryKeyJoinColumn, we annotate User field in Address with @JoinColumn, and that’s it. This tells Hibernate that it should create a separate foreign key column referencing user, instead of using primary key as foreign key. 

## Entity Framework Core

In EF Core, we need a bit more work. First of all, we have to explicitly define a new field which will hold foreign key values:

![C#SeparateForeignKeyColumn](/assets/OTOC#-Separate.png)

After that, in OnModelCreating method, we need to tell the ORM to use that field as foreign key column:

![C#SeparateModel](/assets/OTOC#-Separate-M.png)

Persisting instances works the same. 

## Intermediate Table

### Beauty of Hibernate's @JoinTable

The third option, which is to use an intermedaite table is offered to us by Hibernate out of the box. The connection is contained within the intermediate table only, and the tables that are connected have no reference to each other in their concrete tables.  The relationship is assumed to be unidirectional. This approach is handy if the relationship is optional. We make columns non-nullable: If a connection exists, the corresponding row will be present in the intermediate table, and if not - the row simply won’t exist at all, instead of having null values. 

Since the relationship is unidirectional, we need to annotate one class like this.

![JoinTable](/assets/joinTable.png)

We don't even have to create a new class! Hibernate will create a table automatically. Only @JoinTable’s name parameter is required. @JoinColumn annotations are optional, if we want to override default behaviour.

### Entity Framework Core

As far as I know, unlike Hibernate, EF Core does not have this option ready for action. Of course, it is absolutely possible, but we have to manually create a new class, which would represent the intermediate table, and write configuration so that it will hold foreign keys to the entities we want to connect. 

## Conclusion

In this post, I tried to summarize the process of mapping One-To-One relationship between entities using Entity Framework Core and Hibernate. Some things are easier in one ORM, others in another, but overall both are brilliant and reliable. Thanks for reading







